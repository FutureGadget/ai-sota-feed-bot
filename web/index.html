<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>AI Feed</title>
  <link rel="stylesheet" href="https://oat.ink/oat.min.css" />
  <script>
    (function () {
      var t = localStorage.getItem('theme') || (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light');
      document.documentElement.setAttribute('data-theme', t);
    })();
  </script>
  <script src="https://oat.ink/oat.min.js" defer></script>
  <style>
    html {
      font-size: 16px;
      -webkit-text-size-adjust: 100%;
      text-size-adjust: 100%;
    }
    body {
      margin: 0;
      line-height: 1.5;
      overflow-x: hidden;
    }
    *, *::before, *::after {
      box-sizing: border-box;
    }
    main {
      width: 100%;
      max-width: 920px;
      margin: 1rem auto;
      padding: 0 0.9rem 2rem;
      overflow-x: clip;
    }
    header {
      margin-bottom: 1rem;
    }
    .topbar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.75rem;
    }
    .topbar h1 {
      margin: 0;
      font-size: 1.5rem;
      line-height: 1.2;
      overflow-wrap: anywhere;
    }
    menu {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      padding: 0;
      margin: 0.75rem 0 0;
    }
    .presets {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-top: 0.9rem;
    }
    .presets button {
      font-size: 0.9rem;
      padding: 0.3rem 0.55rem;
    }
    .filters {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 0.6rem;
      margin-top: 0.8rem;
      align-items: end;
    }
    .filters label {
      font-size: 0.92rem;
      opacity: 0.9;
      display: block;
      margin-bottom: 0.25rem;
    }
    .filters .actions {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
    }
    .filter-control {
      width: 100%;
      min-height: 56px;
    }
    .label-filter {
      display: flex;
      flex-direction: column;
    }
    #labelPickerWrap {
      display: block;
      width: 100%;
    }
    .label-filter #labelPickerBtn {
      width: 100%;
      min-height: 56px;
      padding: 0.65rem 0.9rem;
      text-align: left;
      display: inline-flex;
      align-items: center;
      justify-content: flex-start;
      margin: 0;
      line-height: 1.2;
      font-size: 16px;
    }
    #list {
      display: grid;
      gap: 0.75rem;
      margin-top: 1rem;
    }
    article {
      padding: 1rem;
      border: 1px solid var(--border, #e5e5e5);
      border-radius: 10px;
      background: var(--card, #fff);
    }
    .thumb {
      display: block;
      width: 100%;
      max-height: 220px;
      object-fit: cover;
      border-radius: 8px;
      margin-bottom: 0.6rem;
      border: 1px solid var(--border, #e5e5e5);
    }
    article h3 {
      margin: 0 0 0.35rem;
      font-size: 1.15rem;
      line-height: 1.35;
      overflow-wrap: anywhere;
      word-break: break-word;
    }
    article h3 a {
      overflow-wrap: anywhere;
      word-break: break-word;
    }
    .meta-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
      margin: 0.45rem 0;
      min-width: 0;
    }
    .badge {
      display: inline-block;
      max-width: 100%;
      border: 1px solid var(--border, #d9d9d9);
      border-radius: 999px;
      padding: 0.18rem 0.55rem;
      font-size: 0.86rem;
      opacity: 0.92;
      overflow-wrap: anywhere;
      word-break: break-word;
    }
    .badge-fresh {
      border-color: #16a34a;
      color: #166534;
      background: #ecfdf3;
      font-weight: 600;
    }
    .why {
      margin: 0.35rem 0 0;
      font-size: 1rem;
      line-height: 1.55;
      overflow-wrap: anywhere;
      word-break: break-word;
    }
    .state {
      border: 1px dashed var(--border, #d9d9d9);
      border-radius: 10px;
      padding: 1rem;
      opacity: 0.85;
    }
    input, button, a[role="button"] {
      font-size: 16px;
    }
    @media (max-width: 640px) {
      main {
        margin-top: 0.75rem;
      }
      .topbar h1 {
        font-size: 1.35rem;
      }
    }
  </style>
</head>
<body>
  <main>
    <header>
      <div class="topbar">
        <h1>ðŸ“° AI Feed</h1>
        <button id="themeToggle" type="button" aria-label="Toggle theme">ðŸŒ™ Dark</button>
      </div>
      <p id="meta">Loading...</p>
      <menu>
        <a href="/api/rss" role="button">RSS feed</a>
        <a href="/api/feed" role="button">JSON feed</a>
      </menu>

      <div class="presets" id="presets">
        <button type="button" data-days="0">Today</button>
        <button type="button" data-days="3">Last 3d</button>
        <button type="button" data-days="7">Last 7d</button>
        <button type="button" data-days="30">Last 30d</button>
        <button type="button" data-days="all">All</button>
      </div>


    </header>

    <section id="list" aria-live="polite"></section>
  </main>

  <script>
    function applyTheme(theme) {
      document.documentElement.setAttribute('data-theme', theme);
      localStorage.setItem('theme', theme);
      const btn = document.getElementById('themeToggle');
      if (btn) btn.textContent = theme === 'dark' ? 'â˜€ï¸ Light' : 'ðŸŒ™ Dark';
    }

    function initThemeToggle() {
      const btn = document.getElementById('themeToggle');
      if (!btn) return;
      const current = document.documentElement.getAttribute('data-theme') || 'light';
      applyTheme(current);
      btn.addEventListener('click', () => {
        const now = document.documentElement.getAttribute('data-theme') || 'light';
        applyTheme(now === 'dark' ? 'light' : 'dark');
      });
    }

    function fmtDateTime(v) {
      if (!v) return null;
      const d = new Date(v);
      if (Number.isNaN(d.getTime())) return null;
      return d.toLocaleString();
    }

    function toIsoDateStart(dateStr) {
      if (!dateStr) return null;
      return `${dateStr}T00:00:00`;
    }

    function toIsoDateEnd(dateStr) {
      if (!dateStr) return null;
      return `${dateStr}T23:59:59`;
    }

    function toDateInput(d) {
      const local = new Date(d.getTime() - d.getTimezoneOffset() * 60000);
      return local.toISOString().slice(0, 10);
    }

    let presetDaysState = '7';

    function setDateRangeDays(days) {
      presetDaysState = String(days);

      const fromEl = document.getElementById('fromDate');
      const toEl = document.getElementById('toDate');
      if (!fromEl || !toEl) return;

      if (days === 'all') {
        fromEl.value = '';
        toEl.value = '';
        return;
      }

      const n = Number(days);
      const now = new Date();
      const from = new Date(now.getTime() - n * 24 * 60 * 60 * 1000);
      fromEl.value = toDateInput(from);
      toEl.value = toDateInput(now);
    }

    function setDefaultFilterWindow() {
      setDateRangeDays(7);
    }

    let selectedLabelsState = new Set();

    function normalizeLabel(v) {
      return String(v || '')
        .trim()
        .toLowerCase()
        .replace(/^#+/, '')
        .replace(/\s+/g, '_');
    }

    function getSelectedLabels() {
      return [...selectedLabelsState];
    }

    function setSelectedLabels(values) {
      selectedLabelsState = new Set(
        (Array.isArray(values) ? values : [])
          .map((v) => normalizeLabel(v))
          .filter(Boolean)
      );
      renderSelectedLabelsChips();
      updateLabelPickerButton();
    }

    function updateLabelPickerButton() {
      const btn = document.getElementById('labelPickerBtn');
      if (!btn) return;
      const n = selectedLabelsState.size;
      btn.textContent = n > 0 ? `Labels (${n})` : 'Choose labels';
    }

    function renderSelectedLabelsChips() {
      const box = document.getElementById('selectedLabels');
      if (!box) return;
      const labels = getSelectedLabels();
      if (!labels.length) {
        box.innerHTML = '';
        return;
      }
      box.innerHTML = labels.map((l) => `<button type="button" class="badge" data-chip-remove="${esc(l)}">#${esc(l)} Ã—</button>`).join('');
    }

    function syncLabelOptions(available) {
      const box = document.getElementById('labelOptions');
      if (!box) return;
      const selected = new Set(getSelectedLabels());
      const q = String(document.getElementById('labelSearch')?.value || '').trim().toLowerCase();
      const dedup = new Map();
      for (const x of (Array.isArray(available) ? available : [])) {
        const v = normalizeLabel(x?.label);
        if (!v) continue;
        const c = Number(x?.count || 0);
        dedup.set(v, Number(dedup.get(v) || 0) + c);
      }

      const labels = [...dedup.entries()]
        .map(([label, count]) => ({ label, count }))
        .filter((x) => !q || x.label.includes(q));

      box.innerHTML = labels.map((x) => {
        const v = x.label;
        const c = Number(x?.count || 0);
        if (!v) return '';
        const safe = esc(v);
        const checked = selected.has(v) ? ' checked' : '';
        return `<label><input type="checkbox" data-label-opt="${safe}" value="${safe}"${checked} /> ${safe} (${c})</label>`;
      }).join('');
    }

    function buildFeedUrl() {
      const fromDate = document.getElementById('fromDate')?.value || '';
      const toDate = document.getElementById('toDate')?.value || '';

      let from = toIsoDateStart(fromDate);
      let to = toIsoDateEnd(toDate);
      if (!from && !to && presetDaysState !== 'all') {
        const n = Number(presetDaysState || 7);
        const now = new Date();
        const fromD = new Date(now.getTime() - n * 24 * 60 * 60 * 1000);
        from = toIsoDateStart(toDateInput(fromD));
        to = toIsoDateEnd(toDateInput(now));
      }

      const limit = document.getElementById('limit')?.value || '200';
      const anon = getAnonUserId();
      const labels = getSelectedLabels();
      const u = new URL('/api/feed', window.location.origin);
      if (from) u.searchParams.set('from', from);
      if (to) u.searchParams.set('to', to);
      if (limit) u.searchParams.set('limit', limit);
      for (const l of labels) u.searchParams.append('label', l);
      if (anon) u.searchParams.set('anon_user_id', anon);
      return u.pathname + u.search;
    }

    function esc(v) {
      return String(v ?? '')
        .replaceAll('&', '&amp;')
        .replaceAll('<', '&lt;')
        .replaceAll('>', '&gt;')
        .replaceAll('"', '&quot;')
        .replaceAll("'", '&#39;');
    }

    function safeUrl(v) {
      try {
        const u = new URL(String(v || ''), window.location.origin);
        if (u.protocol === 'http:' || u.protocol === 'https:') return u.href;
      } catch {}
      return '#';
    }

    function randomId(prefix = 'id') {
      if (window.crypto?.randomUUID) return `${prefix}_${window.crypto.randomUUID()}`;
      return `${prefix}_${Math.random().toString(36).slice(2)}_${Date.now()}`;
    }

    async function initPosthog() {
      try {
        const res = await fetch('/api/client-config');
        if (!res.ok) return;
        const cfg = await res.json();
        const ph = cfg?.posthog || {};
        if (!ph.enabled || !ph.project_api_key) return;

        (function(document, posthog){
          if (posthog.__SV) return;
          window.posthog = posthog;
          posthog._i = posthog._i || [];
          posthog.__SV = 1;
          posthog.init = function(apiKey, options, name){
            const target = name ? (posthog[name] = []) : posthog;
            target.people = target.people || [];
            const methods = ['capture','identify','alias','people.set','people.set_once','register','register_once','unregister','reset','isFeatureEnabled'];
            const factory = function(method){
              return function(){
                target.push([method].concat(Array.prototype.slice.call(arguments, 0)));
              };
            };
            for (const m of methods) {
              const parts = m.split('.');
              if (parts.length === 2) {
                target[parts[0]][parts[1]] = factory(m);
              } else {
                target[m] = factory(m);
              }
            }
            posthog._i.push([apiKey, options, name]);
          };
        })(document, window.posthog || []);

        window.posthog.init(ph.project_api_key, {
          api_host: ph.host || 'https://us.i.posthog.com',
          person_profiles: 'identified_only',
          autocapture: false,
          capture_pageview: false,
          capture_pageleave: true,
          persistence: 'localStorage+cookie',
          loaded: (sdk) => {
            const anon = getAnonUserId();
            sdk.identify(anon);
            sdk.capture('page_view', {
              path: window.location.pathname,
              referrer: document.referrer || null,
            });
            window.__posthogEnabled = true;
          },
        });

        if (!document.getElementById('posthog-array-js')) {
          const s = document.createElement('script');
          s.id = 'posthog-array-js';
          s.async = true;
          s.crossOrigin = 'anonymous';
          s.src = (ph.host || 'https://us.i.posthog.com').replace('.i.posthog.com', '-assets.i.posthog.com') + '/static/array.js';
          s.onerror = () => console.debug('posthog_loader_failed');
          document.head.appendChild(s);
        }
      } catch (e) {
        console.debug('posthog_init_failed', e);
      }
    }

    function posthogCapture(event, properties = {}) {
      if (!window.__posthogEnabled || !window.posthog) return;
      try {
        window.posthog.capture(event, properties);
      } catch (e) {
        console.debug('posthog_capture_failed', e);
      }
    }

    function getAnonUserId() {
      const key = 'ai_feed_anon_user_id';
      let v = localStorage.getItem(key);
      if (!v) {
        v = randomId('anon');
        localStorage.setItem(key, v);
      }
      return v;
    }

    function getSessionId() {
      const key = 'ai_feed_session_id';
      let v = sessionStorage.getItem(key);
      if (!v) {
        v = randomId('sess');
        sessionStorage.setItem(key, v);
      }
      return v;
    }

    async function sendEvents(events) {
      if (!events?.length) return;
      try {
        await fetch('/api/events', {
          method: 'POST',
          headers: { 'content-type': 'application/json' },
          body: JSON.stringify({ events }),
          keepalive: true,
        });

        const allImpression = events.every((e) => e.event_type === 'impression');
        if (allImpression) {
          posthogCapture('impression_batch', {
            count: events.length,
            run_id: events[0]?.run_id || null,
          });
        } else {
          for (const ev of events) {
            if (ev.event_type !== 'click') continue;
            posthogCapture('click', {
              item_id: ev.item_id || null,
              source: ev.source || null,
              rank_position: ev.rank_position || null,
              run_id: ev.run_id || null,
              url: ev.url || null,
            });
          }
        }
      } catch (e) {
        console.debug('event_send_failed', e);
      }
    }

    async function run() {
      const list = document.getElementById('list');
      const res = await fetch(buildFeedUrl());
      if (!res.ok) throw new Error(`feed_http_${res.status}`);

      const data = await res.json();
      const items = data.items || [];
      const runs = data.runs || [];
      const tier1Blend = data.tier1_blend || null;
      const availableLabels = data.available_labels || [];
      window.__availableLabels = availableLabels;
      const selectedLabels = getSelectedLabels();
      const anonUserId = getAnonUserId();
      const sessionId = getSessionId();
      const runId = runs?.[0]?.run_at || null;

      syncLabelOptions(availableLabels);

      const freshAdded = Number(tier1Blend?.fresh_added || 0);
      const freshnessNote = freshAdded > 0 ? ` Â· ${freshAdded} fresh` : '';
      const labelNote = selectedLabels.length ? ` Â· labels: ${selectedLabels.join(', ')}` : '';
      document.getElementById('meta').textContent = `${items.length} items Â· ${runs.length} runs in range${freshnessNote}${labelNote}`;

      posthogCapture('feed_view', {
        items_count: items.length,
        runs_count: runs.length,
        fresh_added: freshAdded,
        selected_labels: selectedLabels,
      });

      if (!items.length) {
        list.innerHTML = `<div class="state">No items for that date/time range. Try widening the window.</div>`;
        return;
      }

      list.innerHTML = items.map((it, i) => {
        const seen = fmtDateTime(it.last_seen) || fmtDateTime(it.first_seen);
        const title = esc(it.title || 'Untitled');
        const source = esc(it.source || 'unknown');
        const type = esc(it.type || 'news');
        const maturity = esc(it.maturity || '');
        const tierHint = String(it.tier_hint || '');
        const summaryRaw = String(it.summary_1line || '').replace(/<[^>]+>/g, ' ').replace(/\s+/g, ' ').trim();
        const summary = esc(summaryRaw);
        const seenText = seen ? esc(seen) : '';
        const href = safeUrl(it.url);
        const image = safeUrl(it.image_url || '');
        const itemId = esc(it.id || `${it.url || ''}::${it.title || ''}`);
        const itemRunId = esc(it.ingest_batch_id || it.run_id || runId || '');
        const labels = (() => {
          const seen = new Set();
          const typeNorm = normalizeLabel(it.type || '');
          const out = [];
          for (const raw of (Array.isArray(it.labels) ? it.labels : [])) {
            const v = normalizeLabel(raw);
            if (!v) continue;
            if (v === typeNorm) continue; // avoid duplicate with explicit type badge
            if (seen.has(v)) continue;
            seen.add(v);
            out.push(esc(v));
            if (out.length >= 3) break;
          }
          return out;
        })();

        return `
        <article>
          ${image !== '#' ? `<img class="thumb" src="${image}" alt="" loading="lazy" decoding="async" referrerpolicy="no-referrer" onerror="this.style.display='none';this.remove();" />` : ''}
          <h3>${i + 1}. <a href="${href}" target="_blank" rel="noopener" data-track="item-link" data-item-id="${itemId}" data-source="${source}" data-rank="${i + 1}" data-run-id="${itemRunId}" data-title="${title}">${title}</a></h3>
          <div class="meta-row">
            <span class="badge">${source}</span>
            ${type !== 'news' ? `<span class="badge">${type}</span>` : ''}
            ${tierHint === 'tier1_fresh' ? `<span class="badge badge-fresh">âš¡ Fresh</span>` : ''}
          </div>
          ${summary ? `<p class="why">${summary}</p>` : ''}
        </article>`;
      }).join('');

      const impressions = items.slice(0, 200).map((it, i) => ({
        anon_user_id: anonUserId,
        session_id: sessionId,
        event_type: 'impression',
        item_id: it.id || `${it.url || ''}::${it.title || ''}`,
        title: it.title || '',
        url: it.url || '',
        source: it.source || '',
        rank_position: i + 1,
        run_id: it.ingest_batch_id || it.run_id || runId,
        ts: new Date().toISOString(),
      }));
      sendEvents(impressions);
    }

    function initClickTracking() {
      const list = document.getElementById('list');
      if (!list) return;

      list.addEventListener('click', (e) => {
        const a = e.target.closest('a[data-track="item-link"]');
        if (!a) return;

        const event = {
          anon_user_id: getAnonUserId(),
          session_id: getSessionId(),
          event_type: 'click',
          item_id: a.dataset.itemId || null,
          title: a.dataset.title || null,
          url: a.getAttribute('href') || null,
          source: a.dataset.source || null,
          rank_position: Number(a.dataset.rank || 0) || null,
          run_id: a.dataset.runId || null,
          ts: new Date().toISOString(),
        };
        sendEvents([event]);
      });
    }

    function initFilters() {
      const form = document.getElementById('filters');
      const clearBtn = document.getElementById('clearFilters');
      const presets = document.getElementById('presets');
      const labelPickerWrap = document.getElementById('labelPickerWrap');
      const labelPickerBtn = document.getElementById('labelPickerBtn');
      const labelPicker = document.getElementById('labelPicker');
      const closeLabelPickerBtn = document.getElementById('closeLabelPickerBtn');
      const labelOptions = document.getElementById('labelOptions');
      const labelSearch = document.getElementById('labelSearch');
      const clearLabelsBtn = document.getElementById('clearLabelsBtn');
      const selectedLabelsBox = document.getElementById('selectedLabels');

      form?.addEventListener('submit', (e) => {
        e.preventDefault();
        run().catch(err => {
          document.getElementById('meta').textContent = 'Feed unavailable';
          document.getElementById('list').innerHTML = `<div class="state">Could not load the feed right now. Please refresh in a moment.</div>`;
          console.error(err);
        });
      });

      labelPickerBtn?.addEventListener('click', (e) => {
        e.preventDefault();
        if (!labelPicker) return;
        const willOpen = labelPicker.hasAttribute('hidden');
        if (willOpen) {
          labelPicker.removeAttribute('hidden');
          setTimeout(() => labelSearch?.focus(), 0);
        } else {
          labelPicker.setAttribute('hidden', '');
        }
      });

      closeLabelPickerBtn?.addEventListener('click', () => {
        labelPicker?.setAttribute('hidden', '');
      });

      document.addEventListener('click', (e) => {
        if (!labelPickerWrap || !labelPicker || labelPicker.hasAttribute('hidden')) return;
        if (labelPickerWrap.contains(e.target)) return;
        labelPicker.setAttribute('hidden', '');
      });

      presets?.addEventListener('click', (e) => {
        const btn = e.target.closest('button[data-days]');
        if (!btn) return;
        setDateRangeDays(btn.dataset.days);
        run().catch(err => {
          document.getElementById('meta').textContent = 'Feed unavailable';
          document.getElementById('list').innerHTML = `<div class="state">Could not load the feed right now. Please refresh in a moment.</div>`;
          console.error(err);
        });
      });

      labelSearch?.addEventListener('input', () => {
        syncLabelOptions(window.__availableLabels || []);
      });

      labelOptions?.addEventListener('change', (e) => {
        const input = e.target.closest('input[data-label-opt]');
        if (!input) return;
        const next = new Set(getSelectedLabels());
        const v = String(input.value || '').trim();
        if (!v) return;
        if (input.checked) next.add(v);
        else next.delete(v);
        setSelectedLabels([...next]);
        run().catch(err => {
          document.getElementById('meta').textContent = 'Feed unavailable';
          document.getElementById('list').innerHTML = `<div class="state">Could not load the feed right now. Please refresh in a moment.</div>`;
          console.error(err);
        });
      });

      clearLabelsBtn?.addEventListener('click', () => {
        setSelectedLabels([]);
        syncLabelOptions(window.__availableLabels || []);
        run().catch(err => {
          document.getElementById('meta').textContent = 'Feed unavailable';
          document.getElementById('list').innerHTML = `<div class="state">Could not load the feed right now. Please refresh in a moment.</div>`;
          console.error(err);
        });
      });

      selectedLabelsBox?.addEventListener('click', (e) => {
        const btn = e.target.closest('button[data-chip-remove]');
        if (!btn) return;
        const v = btn.getAttribute('data-chip-remove') || '';
        const next = new Set(getSelectedLabels());
        next.delete(v);
        setSelectedLabels([...next]);
        syncLabelOptions(window.__availableLabels || []);
        run().catch(err => {
          document.getElementById('meta').textContent = 'Feed unavailable';
          document.getElementById('list').innerHTML = `<div class="state">Could not load the feed right now. Please refresh in a moment.</div>`;
          console.error(err);
        });
      });

      clearBtn?.addEventListener('click', () => {
        document.getElementById('fromDate').value = '';
        document.getElementById('toDate').value = '';
        document.getElementById('limit').value = '200';
        setSelectedLabels([]);
        syncLabelOptions(window.__availableLabels || []);
        run().catch(err => {
          document.getElementById('meta').textContent = 'Feed unavailable';
          document.getElementById('list').innerHTML = `<div class="state">Could not load the feed right now. Please refresh in a moment.</div>`;
          console.error(err);
        });
      });
    }

    initThemeToggle();
    setDefaultFilterWindow();
    setSelectedLabels([]);
    initFilters();
    initClickTracking();
    initPosthog();
    run().catch(err => {
      document.getElementById('meta').textContent = 'Feed unavailable';
      document.getElementById('list').innerHTML = `<div class="state">Could not load the feed right now. Please refresh in a moment.</div>`;
      console.error(err);
    });
  </script>
</body>
</html>
